extern crate utils;
use chrono::prelude::*;
use exonum_crypto::Hash;
use exonum_merkledb::{impl_object_hash_for_binary_value, BinaryValue, ObjectHash};
use failure::Error;
use std::{borrow::Cow, convert::AsRef};

use std::collections::HashMap;
use utils::keypair::{CryptoKeypair, Keypair, KeypairType, PublicKey, PublicKeyType, Verify};
use utils::serializer::{serialize, Deserialize, Serialize};

use crate::user_messages::Transaction;

// Include the `messages` module, which is generated from user_transactions.proto.
//Assumption:- messages.rs is generated by prost_build (build.rs) in the same direcrory as __this__ file.
pub mod transactions {
    include!(concat!(".", "/user_messages.rs"));
    //include!(concat!(env!("OUT_DIR"), "messages.rs"));
}

pub trait Txn {
    type T;
    type U;
    // generate trait is only for testing purpose
    fn generate(kp: &Self::U) -> Self::T;
    fn validate(&self, publickey: &PublicKeyType) -> bool;
    fn sign(&self, kp: &Self::U) -> Vec<u8>;
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum DataTypes {
    String,
    Vec(String),
    Number(u64),
}

//below struct is now being generated by build.rs using transactions.proto.
// #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
// pub struct Transaction {
//     /* TODO:
//     // Priority for a transaction. Additive. Higher is better.
//     pub type TransactionPriority = u64;
//     // Minimum number of blocks a transaction will remain valid for.
//     // `TransactionLongevity::max_value()` means "forever".
//     pub type TransactionLongevity = u64;
//     // Tag for a transaction. No two transactions with the same tag should be placed on-chain.
//     pub type TransactionTag = Vec<u8>;
//     */
//     pub nonce: u64,
//     pub from: String,
//     pub to: String,
//     pub fxn_call: String,
//     // TODO:: payload is for fxn_call variables
//     // update payload type and add/remove in future as per requirement
//     pub payload: Vec<DataTypes>,
//     pub amount: u64,
// }

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct SignedTransaction {
    pub txn: Transaction,
    // TODO::
    // update header type and add/remove in future as per requirement
    pub header: HashMap<String, String>,
    pub signature: Vec<u8>,
}

impl Txn for Transaction {
    type T = Transaction;
    type U = KeypairType;

    fn validate(&self, _: &PublicKeyType) -> bool {
        unimplemented!();
    }

    fn sign(&self, kp: &KeypairType) -> Vec<u8> {
        let ser_txn = serialize(&self);
        let sign = Keypair::sign(&kp, &ser_txn);
        sign
    }

    fn generate(kp: &KeypairType) -> Transaction {
        let from: String = hex::encode(kp.public().encode());
        let to_add_kp = Keypair::generate();
        let to: String = hex::encode(to_add_kp.public().encode());
        Transaction {
            nonce: 0,
            from,
            to,
            amount: 32,
            fxn_call: String::from("transfer"),
            payload: vec![],
        }
    }
}

impl Txn for SignedTransaction {
    type T = SignedTransaction;
    type U = KeypairType;

    fn validate(&self, publickey: &PublicKeyType) -> bool {
        let ser_txn = serialize(&self.txn);
        PublicKey::verify(&publickey, &ser_txn, &self.signature.as_ref())
    }

    fn sign(&self, kp: &KeypairType) -> Vec<u8> {
        let ser_txn = serialize(&self.txn);
        let sign = Keypair::sign(&kp, &ser_txn);
        sign
    }

    fn generate(kp: &KeypairType) -> SignedTransaction {
        let from: String = hex::encode(kp.public().encode());
        let to_add_kp = Keypair::generate();
        let to: String = hex::encode(to_add_kp.public().encode());
        let txn: Transaction = Transaction {
            nonce: 0,
            from,
            to,
            amount: 32,
            fxn_call: String::from("transfer"),
            payload: vec![],
        };
        let txn_sign = txn.sign(&kp);
        let mut header = HashMap::default();
        header.insert("timestamp".to_string(), Local::now().to_string());
        SignedTransaction {
            txn,
            signature: txn_sign,
            header,
        }
    }
}

impl BinaryValue for SignedTransaction {
    fn to_bytes(&self) -> Vec<u8> {
        bincode::serialize(self).unwrap()
    }

    fn from_bytes(bytes: Cow<'_, [u8]>) -> Result<Self, Error> {
        bincode::deserialize(bytes.as_ref()).map_err(From::from)
    }
}

impl_object_hash_for_binary_value! { SignedTransaction}

#[cfg(test)]
mod tests_transactions {

    #[test]
    pub fn main_transaction() {
        use super::*;
        let kp = Keypair::generate();
        let public_key = Keypair::public(&kp);
        let signed_txn = SignedTransaction::generate(&kp);
        let validate_txn = signed_txn.validate(&public_key);
        match validate_txn {
            true => println!("Transaction Validation Passed."),
            _ => println!("Transaction Validation failed!!!"),
        }
    }
}
